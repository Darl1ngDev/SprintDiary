## 代码随想录

### 数组

#### 数组1.二分查找

**LeetCode：704. 二分查找**



### 链表

### Hash

### 字符串

### 栈、队列

### 二叉树

### 回溯

### 贪心

### dp

### 单调栈

## 每日一题

#### Leetcode2680. 最大或值——25.3.21

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` 。每一次操作中，你可以选择一个数并将它乘 `2` 。

你最多可以进行 `k` 次操作，请你返回 `nums[0] | nums[1] | ... | nums[n - 1]` 的最大值。

`a | b` 表示两个整数 `a` 和 `b` 的 **按位或** 运算。

 

**示例 1：**

```
输入：nums = [12,9], k = 1
输出：30
解释：如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。
```

**示例 2：**

```
输入：nums = [8,1,2], k = 2
输出：35
解释：如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 15`

**解题思路：**

贪心思想，将左移操作全作用于一个最长的数。

先从后向前遍历得到一个后缀按位异或和`suf`。`suf[i] `表示` nums[i+1]` 到 `nums[n-1] `的 异或结果。

然后从头开始遍历，初始化前缀异或值`pre`和结果`ans`。依次更新前缀，维护一个`pre`|`nums[i]<<k`|`suf`最大值即为所求。需注意结果类型，int会爆


```go
func maximumOr(nums []int, k int) int64 {
    n := len(nums)
    suf := make([]int, n)
    for i := n - 2; i >= 0; i-- {
        suf[i] = suf[i+1] | nums[i+1]
    }

    ans, pre := 0, 0
    for i,x := range nums{
        ans = max(ans,pre|x<<k|suf[i])
        pre |= x
    }
    return int64(ans)
}
```

#### Leetcode2643. 一最多的行——25.3.22

给你一个大小为 `m x n` 的二进制矩阵 `mat` ，请你找出包含最多 **1** 的行的下标（从 **0** 开始）以及这一行中 **1** 的数目。

如果有多行包含最多的 1 ，只需要选择 **行下标最小** 的那一行。

返回一个由行下标和该行中 1 的数量组成的数组。

 

**示例 1：**

```
输入：mat = [[0,1],[1,0]]
输出：[0,1]
解释：两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。 
```

**示例 2：**

```
输入：mat = [[0,0,0],[0,1,1]]
输出：[1,2]
解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。
```

**示例 3：**

```
输入：mat = [[0,0],[1,1],[0,0]]
输出：[1,2]
解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。
```

**提示：**

- `m == mat.length` 
- `n == mat[i].length` 
- `1 <= m, n <= 100` 
- `mat[i][j]` 为 `0` 或 `1`

**解题思路：**

遍历，记得调整好这种遍历思想，总用`ij`来循环不够精巧

```go
func rowAndMaximumOnes(mat [][]int) []int {
    rowIdx, maxSum := -1, -1
    for i, row := range mat {
        count :=0
        for _, x := range row{
            count += x
        }
        if count > maxSum {
            rowIdx = i
            maxSum = count
        }
    }
    return []int{rowIdx,maxSum}
}
```

