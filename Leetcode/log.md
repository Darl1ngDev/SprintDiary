## 代码随想录

### 数组

#### 数组1.二分查找

**LeetCode：704. 二分查找**

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。

2. `n` 将在 `[1, 10000]`之间。

3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

**解题思路：**

左闭右闭，注意`mid`的取值要加上补上`left`偏置

最后注意`if-else`的格式规范，`else`前面必须是上一个`if`或者`else if`的括回，且不能换行

```go
   func search(nums []int, target int) int {
    n := len(nums)
    left := 0
    right := n-1
    for left <= right {
        mid := (right - left)/2 + left
        if target == nums[mid]{
            return mid
        } else if target < nums[mid] { 
            right = mid -1
        } else{
            left = mid + 1
        }
    }
    return -1
}
```

   #### 数组2.移除元素

**LeetCode：27. 移除元素**

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

**提示：**

- `0 <= nums.length <= 100`

- `0 <= nums[i] <= 50`

- `0 <= val <= 100`

**解题思路：**

这题叙述上有点难理解，实际就是把这个数组中目标元素删除，重新组成一个新的排列，顺序无所谓

这里用的是一次遍历，我们有一个`count`记录非`val`的元素数量

每次读到非`val`元素，就会将当前当前元素赋值到`nums[count]`的位置，同时`count++`

遍历结束后，我们会得到一个前`count`个元素均非`val`，将其切片重新赋值给`nums`即可

但是好像不用切片也行，题解没写这个

```go
func removeElement(nums []int, val int) int {
    count := 0
    for _, num := range nums {
        if num != val{
            nums[count] = num
            count++
        }
    }
    nums = nums[0:count]
    return count
}
```




### 链表

### Hash

### 字符串

### 栈、队列

### 二叉树

### 回溯

### 贪心

### dp

### 单调栈

## 每日一题

#### Leetcode2680. 最大或值——25.3.21

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` 。每一次操作中，你可以选择一个数并将它乘 `2` 。

你最多可以进行 `k` 次操作，请你返回 `nums[0] | nums[1] | ... | nums[n - 1]` 的最大值。

`a | b` 表示两个整数 `a` 和 `b` 的 **按位或** 运算。

 

**示例 1：**

```
输入：nums = [12,9], k = 1
输出：30
解释：如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。
```

**示例 2：**

```
输入：nums = [8,1,2], k = 2
输出：35
解释：如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 15`

**解题思路：**

贪心思想，将左移操作全作用于一个最长的数。

先从后向前遍历得到一个后缀按位异或和`suf`。`suf[i] `表示` nums[i+1]` 到 `nums[n-1] `的 异或结果。

然后从头开始遍历，初始化前缀异或值`pre`和结果`ans`。依次更新前缀，维护一个`pre`|`nums[i]<<k`|`suf`最大值即为所求。需注意结果类型，int会爆


```go
func maximumOr(nums []int, k int) int64 {
    n := len(nums)
    suf := make([]int, n)
    for i := n - 2; i >= 0; i-- {
        suf[i] = suf[i+1] | nums[i+1]
    }

    ans, pre := 0, 0
    for i,x := range nums{
        ans = max(ans,pre|x<<k|suf[i])
        pre |= x
    }
    return int64(ans)
}
```

#### Leetcode2643. 一最多的行——25.3.22

给你一个大小为 `m x n` 的二进制矩阵 `mat` ，请你找出包含最多 **1** 的行的下标（从 **0** 开始）以及这一行中 **1** 的数目。

如果有多行包含最多的 1 ，只需要选择 **行下标最小** 的那一行。

返回一个由行下标和该行中 1 的数量组成的数组。

 

**示例 1：**

```
输入：mat = [[0,1],[1,0]]
输出：[0,1]
解释：两行中 1 的数量相同。所以返回下标最小的行，下标为 0 。该行 1 的数量为 1 。所以，答案为 [0,1] 。 
```

**示例 2：**

```
输入：mat = [[0,0,0],[0,1,1]]
输出：[1,2]
解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。
```

**示例 3：**

```
输入：mat = [[0,0],[1,1],[0,0]]
输出：[1,2]
解释：下标为 1 的行中 1 的数量最多。该行 1 的数量为 2 。所以，答案为 [1,2] 。
```

**提示：**

- `m == mat.length` 
- `n == mat[i].length` 
- `1 <= m, n <= 100` 
- `mat[i][j]` 为 `0` 或 `1`

**解题思路：**

遍历，记得调整好这种遍历思想，总用`ij`来循环不够精巧

```go
func rowAndMaximumOnes(mat [][]int) []int {
    rowIdx, maxSum := -1, -1
    for i, row := range mat {
        count :=0
        for _, x := range row{
            count += x
        }
        if count > maxSum {
            rowIdx = i
            maxSum = count
        }
    }
    return []int{rowIdx,maxSum}
}
```

## 

#### Leetcode2116. 判断一个括号字符串是否有效——25.3.23

一个括号字符串是只由 `'('` 和 `')'` 组成的 **非空** 字符串。如果一个字符串满足下面 **任意** 一个条件，那么它就是有效的：

- 字符串为 `()`.
- 它可以表示为 `AB`（`A` 与 `B` 连接），其中`A` 和 `B` 都是有效括号字符串。
- 它可以表示为 `(A)` ，其中 `A` 是一个有效括号字符串。

给你一个括号字符串 `s` 和一个字符串 `locked` ，两者长度都为 `n` 。`locked` 是一个二进制字符串，只包含 `'0'` 和 `'1'` 。对于 `locked` 中 **每一个** 下标 `i` ：

- 如果 `locked[i]` 是 `'1'` ，你 **不能** 改变 `s[i]` 。
- 如果 `locked[i]` 是 `'0'` ，你 **可以** 将 `s[i]` 变为 `'('` 或者 `')'` 。

如果你可以将 `s` 变为有效括号字符串，请你返回 `true` ，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/11/06/eg1.png)

```
输入：s = "))()))", locked = "010100"
输出：true
解释：locked[1] == '1' 和 locked[3] == '1' ，所以我们无法改变 s[1] 或者 s[3] 。
我们可以将 s[0] 和 s[4] 变为 '(' ，不改变 s[2] 和 s[5] ，使 s 变为有效字符串。
```

**示例 2：**

```
输入：s = "()()", locked = "0000"
输出：true
解释：我们不需要做任何改变，因为 s 已经是有效字符串了。
```

**示例 3：**

```
输入：s = ")", locked = "0"
输出：false
解释：locked 允许改变 s[0] 。
但无论将 s[0] 变为 '(' 或者 ')' 都无法使 s 变为有效字符串。
```

**示例 4：**

```
输入：s = "(((())(((())", locked = "111111010111"
输出：true
解释：locked 允许我们改变 s[6] 和 s[8]。
我们将 s[6] 和 s[8] 改为 ')' 使 s 变为有效字符串。
```

**提示：**

- `n == s.length == locked.length`

- `1 <= n <= 105`

- `s[i]` 要么是 `'('` 要么是 `')'` 。

- `locked[i]` 要么是 `'0'` 要么是 `'1'` 。

**解题思路：**

括号匹配问题，首先定义`(`为加一`)`为减一，这样如果正确匹配应当至少满足遍历一次后，总计数为0

这里需要强调至少是因为`)(`也满足计数为0，但不符合有效匹配

所以我们对`)(`来说，我们定义一个`count = 0`。首先读到`)`，应当减一。但此时`count = 0`，意味着前面没有左括号`(`，此时必然发生失配

所以如果一旦`count`为负，则必然为失配

进一步的我们，考虑括号反转的问题，也就是说，当某处可以发生变动时，他会出现两种括号的情况。由此引发分支

**示例1**

如果 `s=??????`，考察在遍历 *s* 的过程中，未匹配的左括号的个数` c `如何变化。

注意左括号可以让 `c` 加一，右括号可以让 `c` 减一（但不能是负数）。

| *i*  | *$s_i$* | *c* 的取值范围 | 备注                        |
| ---- | ------- | -------------- | --------------------------- |
| 0    | ?       | {1}            | 只能是左括号                |
| 1    | ?       | {0,2}          | 可以是左括号也可以是右括号  |
| 2    | ?       | {1,3}          | 同上（注意 *c* 不能是负数） |
| 3    | ?       | {0,2,4}        | 同上                        |
| 4    | ?       | {1,3,5}        | 同上                        |
| 5    | ?       | {0,2,4,6}      | 同上                        |

最终 *c* 能变成 0，说明我们可以把 *s* 变成有效括号字符串，比如 (())()。例二

如果 `s=??())?))`，考察在遍历 `s`的过程中，未匹配的左括号的个数 *c* 如何变化。

| *i*  | $s_i$ | *c* 的取值范围 | 备注                       |
| ---- | ----- | -------------- | -------------------------- |
| 0    | ?     | {1}            | 只能是左括号               |
| 1    | ?     | {0,2}          | 可以是左括号也可以是右括号 |
| 2    | (     | {1,3}          | 所有 *c* 加一              |
| 3    | )     | {0,2}          | 所有 *c* 减一              |
| 4    | )     | {1}            | 所有 *c* 减一，去掉负数    |
| 5    | ?     | {0,2}          | 可以是左括号也可以是右括号 |
| 6    | )     | {1}            | 所有 *c* 减一，去掉负数    |
| 7    | )     | {0}            | 所有 *c* 减一              |

最终 `c` 能变成 0，说明我们可以把 `s` 变成有效括号字符串。本例只有一种方案，即 `((())())`。

**示例2**

如果 `s=?))?`，考察在遍历 `s` 的过程中，未匹配的左括号的个数 `c` 如何变化。

| *i*  | *s**i* | *c* 的取值范围 | 备注                    |
| ---- | ------ | -------------- | ----------------------- |
| 0    | ?      | {1}            | 只能是左括号            |
| 1    | )      | {0}            | 所有 *c* 减一           |
| 2    | )      | {}             | 所有 *c* 减一，去掉负数 |

遍历到 $s_2$ 的时候，`c` 的取值范围为空，说明无法把` ?))? `变成有效括号字符串。

**示例3**

如果 `s=?((?`，考察在遍历 `s` 的过程中，未匹配的左括号的个数 `c` 如何变化。

| *i*  | *s**i* | *c* 的取值范围 | 备注                       |
| ---- | ------ | -------------- | -------------------------- |
| 0    | ?      | {1}            | 只能是左括号               |
| 1    | (      | {2}            | 所有 *c* 加一              |
| 2    | (      | {3}            | 所有 *c* 加一              |
| 3    | ?      | {2,4}          | 可以是左括号也可以是右括号 |

由于最终 *c* 的取值范围不包含 0，我们无法把 `?((? `变成有效括号字符串。

所以我们维护一个区间，其中上下界严格大于等于零

如果读到可变括号，则将上界加一，视为`(`，同时将下界减一视为`)`

在可变符号的情况下，如果发生下界下溢，则将其置为零，上界不可能发生下溢

遇到不可更改的符号，按规则对上下界同时操作，如果发生下界下溢，则发生失配

如果最后下界为0，则说明存在一种情况可以让括号正确匹配


```go
func canBeValid(s, locked string) bool {
    min, max := 0, 0
    for i, lock := range locked {
        if lock == '1' {
            d := 1 - int(s[i]%2*2)
            max += d
            if max < 0 {
                return false
            }
            min += d
        } else {
            max++
            min--
        }
        if min < 0 {
            min = 1
        }
    }
    return min == 0
}
```

