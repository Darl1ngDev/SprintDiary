## 代码随想录

### 数组

#### 占位

### 链表

### Hash

### 字符串

### 栈、队列

### 二叉树

### 回溯

### 贪心

### dp

### 单调栈

## 每日一题

#### Leetcode2680. 最大或值——25.3.21

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 和一个整数 `k` 。每一次操作中，你可以选择一个数并将它乘 `2` 。

你最多可以进行 `k` 次操作，请你返回 `nums[0] | nums[1] | ... | nums[n - 1]` 的最大值。

`a | b` 表示两个整数 `a` 和 `b` 的 **按位或** 运算。

 

**示例 1：**

```
输入：nums = [12,9], k = 1
输出：30
解释：如果我们对下标为 1 的元素进行操作，新的数组为 [12,18] 。此时得到最优答案为 12 和 18 的按位或运算的结果，也就是 30 。
```

**示例 2：**

```
输入：nums = [8,1,2], k = 2
输出：35
解释：如果我们对下标 0 处的元素进行操作，得到新数组 [32,1,2] 。此时得到最优答案为 32|1|2 = 35 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 109`
- `1 <= k <= 15`

**解题思路：**

贪心思想，将左移操作全作用于一个最长的数。

先从后向前遍历得到一个后缀按位异或和`suf`。`suf[i] `表示` nums[i+1]` 到 `nums[n-1] `的 异或结果。

然后从头开始遍历，初始化前缀异或值`pre`和结果`ans`。依次更新前缀，维护一个`pre`|`nums[i]<<k`|`suf`最大值即为所求。需注意结果类型，int会爆


```go
func maximumOr(nums []int, k int) int64 {
    n := len(nums)
    suf := make([]int, n)
    for i := n - 2; i >= 0; i-- {
        suf[i] = suf[i+1] | nums[i+1]
    }

    ans, pre := 0, 0
    for i,x := range nums{
        ans = max(ans,pre|x<<k|suf[i])
        pre |= x
    }
    return int64(ans)
}
```

